# はじめに

# ポインタ

C言語におけるポインタは、メモリ上のアドレスを格納する変数である。

ポインタを使用することで、変数や配列、関数などのメモリ上の位置を直接操作することができる。

こちらを利用すると、例えばデータをコピーする際にメモリにデータを退避することなくアドレス指定のみで完了する。
それにより、無駄なデータ転送を省き、効率的な処理が可能となる。

今回のようなNginxの処理では大量のリクエストを素早く処理しなければならない。
その時にポインタ指定を行うことで、迅速な通信を実現している。


## ポインタの基本

ポインタを宣言するには、データ型の後にアスタリスク * を付ける。
```
int *ptr;
```

変数のメモリアドレスを取得する際は、数値変数(ポインタではない)に`&`を付ける。
```
int a = 10;
int *ptr = &a;
```
のような感じだ。

次に、間接演算子について記載する。
間接演算子とは、"ポインタを明記することで変数を表示されることである。"
つまり、変数を直接明記するのではなく、ポインタで間接的に明記する。

言葉の使い方的には、「ポインタを、変数の間接演算子として使う」といった言い方が適切である。

以上のように、ポインタが指す先の値を取得または変更するには、`*`を利用する。

```
int a = 10;
int *ptr = &a;
printf("%d\n", *ptr); // 'a'の値を表示 : 10
*ptr = 20; // 'a' の値を20に変更
```

### ポインタのアドレスを表示する方法

ここで気になるのは、`printf("%d\n", *ptr)`でポインタ自身ではなく、変数が表示されてしまうのであれば、ポインタを表示させる方法はあるのか？という部分である。

ポインタを表示される方法があれば、メモリのアドレスを見ることができ、足し算やデフラグ具合などを観察できるのではないかと考えている。

それができれば、メモリの全体管理やトレース・効率的な利用がされているかを知ることが可能となる。また、実装しているメモリの容量とポインタのアドレス番地の数で整合性を確かめたりもしたい。

ポインタのアドレスを表示には、間接演算子(*)ではなく、ポインタそのものをprintfで表示する。
ポインタ自体は「メモリのアドレス」を保持しているので、そのアドレスを表示するには`%p`フォーマット指定子を使う。

```
int a = 10;
int *ptr = &a;

printf("ポインタのアドレス : %p\n", ptr); //ここに*は付けない
```

出力例は以下のようになる。

```
ポインタのアドレス: 0x7ffeeefdc710
```

アドレスの形式について記載する。
メモリアドレスは通常、16進数で表される。
`0x` は16進数の表記を示し、その後に続く数字と文字はメモリの位置を表す。

### メモリアドレスの範囲について
次に気になるのは、メモリアドレスの範囲である。
アドレスには、下限と上限があるはずで、その範囲を知りたい。

なぜなら、それを知ることで「今この変数はメモリのこの部分を使っているのだな」とイメージできるからである。

今後は、そのメモリアドレスと利用率の推移などを可視化していきたい。

メモリのアドレス範囲は、システムのアーキテクチャ（32ビットか64ビット）やオペレーティングシステムのメモリ管理方式に依存する。

例えば、32GBのメモリがある64ビットシステムの場合、ポインタのアドレス範囲については以下が重要となる。


#### 64ビット(8バイト)システムのアドレス空間
64ビットシステムとは、コンピュータのプロセッサ（CPU）が一度に64ビット（8バイト）のデータを処理できるアーキテクチャである。

なぜこれが、メモリと繋がるか　これはデータとアドレスを区別して考える必要がある。

プロセッサが一度に64ビット（8バイト）の情報(データとは限らない)を処理できる能力を持つことである。言い換えれば、一度に64個のON,OFFスイッチを操作可能であるということである。

この、64個のON,OFFは、組み合わせだと2^64通り存在する。
これをメモリのアドレスに適用すれば、理論上2^64個のアドレスを利用できるということになり、それは約18エクサバイト（18,000,000テラバイト）に相当する。

つまり、64ビットシステムでは、理論上約18エクサバイト（1エクサバイト = 1億ギガバイト）のメモリ空間をアドレス指定できる。

64ビットシステムでは、理論上のアドレス空間は `0x0000000000000000` から`0xFFFFFFFFFFFFFFFF` までの 18エクサバイト (2^64 bytes) になる。

しかし、現実には物理的なメモリ容量の制限がある。

#### 32GBのメモリのアドレス範囲

物理的に32GBのメモリがある場合、そのアドレス範囲は次のように計算される。

考え方としては、32GBを2のn乗の形であらわす。
そのうえで、10進数で何個のON,OFFスイッチか割り出し、16進数に変換する。

1GB = 2^30 バイト
32GB = 32 × 2^30 = 2^35 バイト

つまり、32GBのメモリは 0x000000000000 から 0x0000007FFFFFFFFF の範囲に対応する。
（2^35 - 1 = 0x7FFFFFFFFF）。

# スイッチについて
次に気になってくるのは、そのスイッチは「何でできているか？」である。